<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Configurez votre handpan Mistral Pans. Choisissez la gamme, la tonalité, le nombre de notes et les options.">
  
  <title>Mistral Pans - Boutique  | Configurez votre handpan</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400;9..144,500;9..144,600;9..144,700&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  
  
  <!-- Styles -->
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="css/boutique.css">
  
  <!-- Admin Styles -->
  <link rel="stylesheet" href="css/admin.css">

</head>
<body id="top" data-page="boutique">

  <!-- Header dynamique -->
  <div id="site-header"></div>

  <!-- ===== BOUTIQUE TABS (Mobile only) ===== -->
  <div class="boutique-tabs" id="boutique-tabs">
    <div class="boutique-tabs__inner">
      <button class="boutique-tab active" data-panel="config">
        Créer sur mesure
      </button>
      <button class="boutique-tab" data-panel="stock">
        En stock
        <span class="boutique-tab__badge">
          <span class="boutique-tab__badge-dot"></span>
          <span id="stock-count-tab">0</span>
        </span>
      </button>
    </div>
  </div>

  <!-- ===== BOUTIQUE WRAPPER ===== -->
  <div class="boutique-wrapper" id="boutique-wrapper">
    
    <!-- PANEL 1: CONFIGURATOR -->
    <div class="boutique-panel boutique-panel--config" id="panel-config">


  <!-- ===== CONFIGURATOR ===== -->
  <main class="configurator">
    
    <!-- LEFT: Player Visual -->
    <section class="config-player">
      <div class="player-container">
        <div class="player-info">
          <h1 class="player-info__name" id="display-name">D Kurd</h1>
          <p class="player-info__notes" id="display-notes">D3 • A3 • Bb3 • C4 • D4 • E4 • F4 • G4 • A4</p>
          <p class="player-info__mood" id="display-mood">9 notes</p>
        </div>
        
        <div class="player-visual" id="player-visual">
          <!-- SVG generated by JS -->
        </div>
        
        <div class="player-legend" id="player-legend">
          <span class="legend-item"><span class="legend-dot legend-dot--tonal"></span> Tonales</span>
        </div>
        
        <div class="player-controls">
          <button class="btn-play" id="btn-play">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
              <polygon points="5,3 19,12 5,21"/>
            </svg>
            <span>Écouter</span>
          </button>
        </div>
      </div>
    </section>
    
    <!-- RIGHT: Options -->
    <section class="config-options">
      <div class="config-options-inner">
        <h2 class="config-title">Configurez votre instrument</h2>
        <p class="config-subtitle">Personnalisez selon vos préférences</p>
        
        <!-- Gamme -->
        <div class="option-group">
          <label class="option-label">Gamme</label>
          <div class="option-chips" id="chips-scale">
            <button class="chip active" data-value="kurd">Kurd</button>
            <button class="chip" data-value="amara">Amara</button>
            <button class="chip" data-value="lowpygmy">Low Pygmy</button>
            <button class="chip" data-value="hijaz">Hijaz</button>
            <button class="chip" data-value="myxolydian">Myxolydian</button>
            <button class="chip" data-value="equinox">Equinox</button>
          </div>
        </div>
        
        <!-- Nombre de notes -->
        <div class="option-group">
          <label class="option-label">Nombre de notes</label>
          <div class="notes-counter">
            <button class="counter-btn" id="notes-minus" aria-label="Moins">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
            </button>
            <span class="counter-value" id="notes-value">9</span>
            <button class="counter-btn" id="notes-plus" aria-label="Plus">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
            </button>
          </div>
          <p class="notes-hint" id="notes-hint"></p>
        </div>
        
        <!-- Plus d'options -->
        <div class="options-advanced">
          <button class="options-toggle" id="toggle-advanced">
            <span>Plus d'options</span>
            <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </button>
          
          <div class="options-advanced-content" id="advanced-content">
            
            <!-- Tonalité -->
            <div class="option-group">
              <label class="option-label">Tonalité <span class="option-value" id="label-tonality">D3</span></label>
              <div class="option-chips" id="chips-tonality">
                <button class="chip" data-value="F2">F2</button>
                <button class="chip" data-value="F#2">F#2</button>
                <button class="chip" data-value="G2">G2</button>
                <button class="chip" data-value="G#2">G#2</button>
                <button class="chip" data-value="A2">A2</button>
                <button class="chip" data-value="A#2">A#2</button>
                <button class="chip" data-value="B2">B2</button>
                <button class="chip" data-value="C3">C3</button>
                <button class="chip" data-value="C#3">C#3</button>
                <button class="chip active" data-value="D3">D3</button>
                <button class="chip" data-value="D#3">D#3</button>
                <button class="chip" data-value="E3">E3</button>
                <button class="chip" data-value="F3">F3</button>
                <button class="chip" data-value="F#3">F#3</button>
                <button class="chip" data-value="G3">G3</button>
              </div>
            </div>
            
            <!-- Accordage -->
            <div class="option-group">
              <label class="option-label">Accordage</label>
              <div class="option-cards option-cards--2" id="cards-tuning">
                <div class="radio-card active" data-value="440">
                  <div class="radio-card__value">440 Hz</div>
                  <div class="radio-card__label">Standard</div>
                </div>
                <div class="radio-card" data-value="432">
                  <div class="radio-card__value">432 Hz</div>
                  <div class="radio-card__label">Harmonique</div>
                </div>
              </div>
            </div>
            
            <!-- Taille -->
            <div class="option-group">
              <label class="option-label">Taille (diamètre)</label>
              <div class="option-cards" id="cards-size">
                <div class="radio-card" data-value="45">
                  <div class="radio-card__value">45 cm</div>
                  <div class="radio-card__label">Compact</div>
                  <div class="radio-card__price">+100 €</div>
                </div>
                <div class="radio-card" data-value="50">
                  <div class="radio-card__value">50 cm</div>
                  <div class="radio-card__label">Medium</div>
                  <div class="radio-card__price">+100 €</div>
                </div>
                <div class="radio-card active" data-value="53">
                  <div class="radio-card__value">53 cm</div>
                  <div class="radio-card__label">Standard</div>
                </div>
              </div>
            </div>
            
          </div>
        </div>
      </div>
      
      <!-- FOOTER: Price & CTA -->
      <div class="config-footer">
        <div class="price-display">
          <span class="price-label">Prix total</span>
          <span class="price-value" id="total-price">1 080 €</span>
        </div>
        
        <a href="commander.html" class="btn btn-primary" id="btn-order">
          Commander cet instrument
        </a>

        <p class="config-note">
          Besoin de conseils ? <a href="#" data-modal="contact">Contactez-moi</a>
        </p>
      </div>
      
    </section>
  </main>
      
    </div><!-- end panel-config -->
    
    <!-- PANEL 2: STOCK -->
    <div class="boutique-panel boutique-panel--stock" id="panel-stock">
    
      <!-- Navigation Band (at top of stock panel) -->
      <div class="boutique-nav-band" id="nav-band">
        <button class="boutique-nav-band__btn" id="nav-band-btn">
          <span id="nav-band-text">Instruments en stock</span>
          <span class="nav-band__badge" id="nav-band-badge">
            <span class="nav-band__badge-dot"></span>
            <span id="nav-band-count">0</span>
          </span>
          <svg class="nav-band__arrow nav-band__arrow--down" id="nav-arrow-down" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
          <svg class="nav-band__arrow nav-band__arrow--up" id="nav-arrow-up" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:none;">
            <polyline points="18 15 12 9 6 15"></polyline>
          </svg>
        </button>
      </div>
  
  <!-- ===== FLASH SALES SECTION ===== -->
  <section class="flash-section" id="flash-sales">
    <div class="flash-container">
      <div class="flash-header">
        <div>
          <h2 class="flash-title">
            Disponibles immédiatement
            <span class="flash-badge">
              <span class="flash-dot" style="width:6px;height:6px;animation:none;"></span>
              <span id="stock-count-section">2</span> en stock
            </span>
          </h2>
          <p class="flash-subtitle">Ces instruments sont prêts à partir. Chaque pièce est unique.</p>
        </div>
      </div>
      
      <div class="flash-cards" id="flash-cards-container">
        <!-- Cards will be loaded by JavaScript -->
      </div>
    </div>
  </section>
  
    </div><!-- end panel-stock -->
  </div><!-- end boutique-wrapper -->
  
  <!-- Dots indicator (Mobile only) -->
  <div class="boutique-dots" id="boutique-dots">
    <button class="boutique-dot active" data-panel="config" aria-label="Configurateur"></button>
    <button class="boutique-dot" data-panel="stock" aria-label="Stock"></button>
  </div>
  
  <!-- Footer dynamique -->
  <div id="site-footer"></div>

  <!-- Contact modal dynamique -->
  <div id="contact-modal-container"></div>

  <!-- Module de faisabilité -->
  <script src="js/feasibility-module.js"></script>

  <script>
    // ===== GAMMES DATA (from ODS file) =====
    const SCALES_DATA = {
      kurd: {
        name: 'Kurd',
        baseRoot: 'D',
        baseOctave: 3,
        useFlats: true,  // Kurd utilise Bb (mode mineur naturel)
        patterns: {
          9: 'D/-A-Bb-C-D-E-F-G-A_',
          10: 'D/-A-Bb-C-D-E-F-G-A-C',
          11: 'D/-A-Bb-C-D-E-F-G-A-C-[D]',
          12: 'D/(F)-(G)-A-Bb-C-D-E-F-G-A-C',
          13: 'D/(F)-(G)-A-Bb-C-D-E-F-G-A-C-[D]',
          14: 'D/(E)-(F)-(G)-A-Bb-C-D-E-F-G-A-C-[D]',
          15: 'D/(C3)-(E)-(F)-(G)-A-Bb-C-D-E-F-G-A-C-[D]',
          16: 'D/(Bb2)-(C3)-(F)-(G)-A-Bb-C-D-E-F-G-A-C-[D]-(E)',
          17: 'D/(C3)-(E3)-(F)-(G)-A-Bb-C-D-E-F-G-A-C-[D]-(E5)-(F5)',
        }
      },
      amara: {
        name: 'Amara',
        baseRoot: 'D',
        baseOctave: 3,
        useFlats: true,  // Amara utilise Bb (dérivé du mode dorien)
        patterns: {
          9: 'D/-A-C-D-E-F-G-A-C_',
          10: 'D/-A-C-D-E-F-G-A-C-D',
          11: 'D/A-(Bb)-C-D-E-F-G-A-C-D',
          12: 'D/(F)-(G)-A-C-D-E-F-G-A-C-D',
          13: 'D/(E)-(F)-(G)-A-C-D-E-F-G-A-C-D',
          14: 'D/(A2)-(C3)-(F)-(G)-A-C-D-E-F-G-A-C-D',
          15: 'D/(C3)-(F)-(G)-A-(Bb)-C-D-E-F-G-A-C-D-[F]',
          16: 'D/(C3)-(E)-(F)-(G)-A-C-D-E-F-G-A-C-D-(E)-(F)',
          17: 'D/(A2)-(C3)-(F)-(G)-A-C-D-E-F-G-A-C-D-[E]-(F)-(G)',
        }
      },
      lowpygmy: {
        name: 'Low Pygmy',
        baseRoot: 'F#',
        baseOctave: 3,
        useFlats: false,  // Low Pygmy utilise F#, G#, C# (gamme à dièses)
        patterns: {
          9: 'F#/-G#-A-C#-E-F#-G#-A-C#',
          10: 'F#/-G#-A-C#-E-F#-G#-A-C#-E',
          11: 'F#/-G#-A-C#-E-F#-G#-A-C#-E-[F#]',
          12: 'F#/-G#-A-C#-E-F#-G#-A-C#-E-[F#]-[G#]',
          13: 'F#/-G#-A-(B)-C#-E-F#-G#-A-C#-E-[F#]-[G#]',
          14: 'F#/-G#-A-(B)-C#-(D)-E-F#-G#-A-C#-E-[F#]-[G#]',
          15: 'F#/-G#-A-(B)-C#-(D)-E-F#-G#-A-(B)-C#-E-[F#]-[G#]',
          16: 'F#/-G#-A-(B)-C#-(D)-E-F#-G#-A-(B)-C#-(D)-E-[F#]-[G#]',
          17: 'F#/-(D3)-(E3)-G#3-A-(B4)-C#4-(D4)-E-F#-G#-A-(B)-C#-E-[F#]-[G#]',
        }
      },
      hijaz: {
        name: 'Hijaz',
        baseRoot: 'D',
        baseOctave: 3,
        useFlats: false,  // Hijaz utilise la seconde augmentée (A#-C#) - dièses
        patterns: {
          9: 'D/-A-A#-C#-D-E-F-G-A',
          10: 'D/-A-A#-C#-D-E-F-G-A-C#',
          11: 'D/-A-A#-C#-D-E-F-G-A-C#-[D]',
          12: 'D/-(E)-(F)-A-A#-C#-D-E-F-G-A-C#',
          13: 'D/-(E)-(F)-A-A#-C#-D-E-F-G-A-C#-[D]',
          14: 'D/-(E)-(F)-(G)-A-A#-C#-D-E-F-G-A-C#-[D]',
          15: 'D/-(E)-(F)-A-A#-C#-D-E-F-G-A-C#-[D]-(E)-(F)',
          16: 'D/-(E)-(F)-(G)-A-A#-C#-D-E-F-G-A-C#-[D]-(E)-(F)',
          17: 'D/-(A#2)-(C#3)-(E)-(F)-A-A#-C#-D-E-F-G-A-C#-[D]-(E)-(F)',
        }
      },
      myxolydian: {
        name: 'Myxolydian',
        baseRoot: 'C',
        baseOctave: 3,
        useFlats: false,  // Myxolydien en Do = notes naturelles (pas d'altération)
        patterns: {
          9: 'C/-G-A-B-C-D-E-F-G',
          10: 'C/-G-A-B-C-D-E-F-G-A',
          11: 'C/-G-A-B-C-D-E-F-G-A-(C)',
          12: 'C/-(E)-(F)-G-A-B-C-D-E-F-G-A',
          13: 'C/-(E)-(F)-G-A-B-C-D-E-F-G-A-(C)',
          14: 'C/-(E)-(F)-G-A-B-C-D-E-F-G-A-(B)-(C)',
          15: 'C/-(D)-(E)-(F)-G-A-B-C-D-E-F-G-A-(B)-(C)',
          16: 'C/-(E)-(F)-G-A-B-C-D-E-F-G-A-(B)-(C)-(D)-(E)',
          17: 'C/-(D)-(E)-(F)-G-A-B-C-D-E-F-G-A-B-(C)-(D)-(E)',
        }
      },
      equinox: {
        name: 'Equinox',
        baseRoot: 'F',
        baseOctave: 3,
        useFlats: true,  // Equinox = Fa mineur, utilise bémols (Ab, Db, Eb)
        patterns: {
          9: 'F/-G#3-C4-C#4-D#4-F4-G4-G#4-C5',
          10: 'F/-G#3-C4-C#4-D#4-F4-G4-G#4-C5-D#',
          11: 'F/-G#3-C4-C#4-D#4-F4-G4-G#4-C5-D#-[F]',
          12: 'F/-G#3-C4-C#4-D#4-F4-G4-G#4-C5-C#-D#-[F]',
          13: 'F/-(C3)-(C#3)-G#3-C4-C#4-D#4-F4-G4-G#4-C5-C#-[F]',
          14: 'F/-(C3)-(C#3)-G#3-C4-C#4-D#4-F4-G4-G#4-C5-C#-D#-[F]',
          15: 'F/-(C3)-(C#3)-(G3)-G#3-C4-C#4-D#4-F4-G4-G#4-C5-C#-D#-[F]',
          16: 'F/-(C3)-(C#3)-(G3)-G#3-C4-C#4-D#4-F4-G4-G#4-C5-C#-D#-[F]-[G]',
          17: 'F/-(C3)-(C#3)-(G3)-G#3-C4-C#4-D#4-F4-G4-G#4-C5-C#-D#-[F]-[G]-[G#]',
        }
      },
    };
    
    // Note names and semitones
    const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    
    // Flats to sharps conversion
    const FLATS_TO_SHARPS = {
      'Db': 'C#', 'Eb': 'D#', 'Fb': 'E', 'Gb': 'F#',
      'Ab': 'G#', 'Bb': 'A#', 'Cb': 'B'
    };

    // Sharps to flats conversion (for display - musical convention)
    const SHARPS_TO_FLATS = {
      'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'
    };

    // Convert sharp notation to flat for display (only if scale uses flats)
    function toDisplayNotation(noteWithOctave, useFlats = false) {
      if (!useFlats) return noteWithOctave;  // Keep sharps for sharp-based scales
      const match = noteWithOctave.match(/^([A-G]#?)(\d)?$/);
      if (!match) return noteWithOctave;
      const note = match[1];
      const octave = match[2] || '';
      const flat = SHARPS_TO_FLATS[note];
      return flat ? flat + octave : noteWithOctave;
    }

    // Determine if we should use flats based on BOTH tonality AND scale
    // Rule: Use flats only if root is a natural note AND scale prefers flats
    // Sharp roots (F#, C#, G#, D#, A#) always use sharps regardless of scale
    function shouldUseFlats(tonality, scaleData) {
      if (!scaleData || !scaleData.useFlats) return false;

      // Extract root note from tonality (e.g., "F#3" -> "F#", "D3" -> "D")
      const match = tonality.match(/^([A-G]#?)(\d)$/);
      if (!match) return false;

      const root = match[1];
      // If root contains sharp, use sharps (F# Kurd, not Gb Kurd)
      if (root.includes('#')) return false;

      // Natural root + scale prefers flats = use flats
      return true;
    }

    // Base frequencies for octave 0
    const BASE_FREQ = 16.35; // C0
    
    // ===== STATE =====
    const state = {
      scale: 'kurd',
      notes: 9,
      tonality: 'D3',
      tuning: '440',
      size: '53'
    };
    
    // ===== PRICING =====
    const pricePerNote = 115;
    const priceOctave2Bonus = 50;  // +50€ par note en octave 2
    const priceBottomBonus = 25;   // +25€ si l'instrument a des bottoms
    const sizeMalus = { '53': 0, '50': 0.025, '45': 0.05 };  // +2.5% pour 50cm, +5% pour 45cm
    
    function calculatePrice(notes, size, feasibilityStatus) {
      let price = 0;
      let hasBottom = false;
      
      notes.forEach(note => {
        price += pricePerNote;
        if (note.octave === 2) {
          price += priceOctave2Bonus;
        }
        if (note.type === 'bottom') {
          hasBottom = true;
        }
      });
      
      // Bonus bottom (une seule fois)
      if (hasBottom) {
        price += priceBottomBonus;
      }
      
      // Malus taille (en %)
      const sizeMultiplier = 1 + (sizeMalus[size] || 0);
      price = price * sizeMultiplier;
      
      // Pourcentage selon difficulté
      if (feasibilityStatus === 'warning') {
        price = price * 1.05;
      } else if (feasibilityStatus === 'difficult') {
        price = price * 1.10;
      }
      
      // Arrondir à la tranche de 5€ inférieure
      return Math.floor(price / 5) * 5;
    }
    
    // ===== AUDIO (FLAC Samples) =====
    const audioCache = {};
    const AUDIO_PATH = 'ressources/audio/';
    
    // Convertir le nom de note interne vers le nom du fichier
    // Ex: "C#4" → "Cs4", "Bb3" → "As3" (Bb = A#)
    function noteToFileName(noteName) {
      // D'abord normaliser les bémols en dièses
      const flatToSharp = {
        'Db': 'Cs', 'Eb': 'Ds', 'Fb': 'E', 'Gb': 'Fs',
        'Ab': 'Gs', 'Bb': 'As', 'Cb': 'B'
      };
      
      let fileName = noteName;
      
      // Remplacer les bémols par leurs équivalents dièses
      for (const [flat, sharp] of Object.entries(flatToSharp)) {
        if (fileName.startsWith(flat)) {
          fileName = fileName.replace(flat, sharp);
          break;
        }
      }
      
      // Remplacer # par s pour le nom de fichier
      fileName = fileName.replace('#', 's');
      
      return fileName;
    }
    
    // Précharger un fichier audio
    async function preloadAudio(noteName) {
      const fileName = noteToFileName(noteName);
      if (audioCache[fileName]) return audioCache[fileName];
      
      try {
        const audio = new Audio(`${AUDIO_PATH}${fileName}.flac`);
        audio.preload = 'auto';
        audioCache[fileName] = audio;
        return audio;
      } catch (e) {
        console.warn(`Impossible de charger ${fileName}.flac`);
        return null;
      }
    }
    
    // Jouer une note
    function playNote(noteName) {
      const fileName = noteToFileName(noteName);
      
      // Vérifier si déjà en cache
      if (audioCache[fileName]) {
        const audio = audioCache[fileName].cloneNode();
        audio.volume = 0.7;
        audio.play().catch(e => console.warn('Erreur lecture audio:', e));
        return;
      }
      
      // Sinon charger et jouer
      const audio = new Audio(`${AUDIO_PATH}${fileName}.flac`);
      audio.volume = 0.7;
      audioCache[fileName] = audio;
      audio.play().catch(e => console.warn('Erreur lecture audio:', e));
    }
    
    // Précharger les notes de la gamme courante
    function preloadCurrentScale() {
      const notes = getCurrentNotes();
      notes.forEach(n => preloadAudio(`${n.note}${n.octave}`));
    }
    
    // Compatibilité avec l'ancien code (freq → note)
    // Garder getFrequency pour le tri des notes par hauteur
    function getFrequency(note, octave) {
      const noteIndex = NOTE_NAMES.indexOf(note);
      if (noteIndex === -1) return 0;
      const semitones = octave * 12 + noteIndex;
      let freq = BASE_FREQ * Math.pow(2, semitones / 12);
      if (state.tuning === '432') freq *= (432 / 440);
      return freq;
    }
    
    // ===== PARSE PATTERN =====
    function normalizeNote(noteStr) {
      for (const [flat, sharp] of Object.entries(FLATS_TO_SHARPS)) {
        if (noteStr.startsWith(flat)) {
          return noteStr.replace(flat, sharp);
        }
      }
      return noteStr;
    }
    
    function parseNote(noteStr) {
      noteStr = normalizeNote(noteStr);
      const match = noteStr.match(/^([A-G]#?)(\d)?$/);
      if (!match) return null;
      return { note: match[1], octave: match[2] ? parseInt(match[2]) : null };
    }
    
    function parsePattern(pattern, rootNote, rootOctave, transpose) {
      const notes = [];
      pattern = pattern.replace(/_$/, '').replace(/\s+/g, ' ').trim();
      
      const slashIndex = pattern.indexOf('/');
      if (slashIndex === -1) return notes;
      
      let notesPart = pattern.substring(slashIndex + 1).trim();
      
      const tokens = [];
      let current = '';
      let inParens = false;
      let inBrackets = false;
      
      for (let i = 0; i < notesPart.length; i++) {
        const char = notesPart[i];
        
        if (char === '(') {
          if (current.trim()) tokens.push(current.trim());
          current = '(';
          inParens = true;
        } else if (char === ')') {
          current += ')';
          tokens.push(current.trim());
          current = '';
          inParens = false;
        } else if (char === '[') {
          if (current.trim()) tokens.push(current.trim());
          current = '[';
          inBrackets = true;
        } else if (char === ']') {
          current += ']';
          tokens.push(current.trim());
          current = '';
          inBrackets = false;
        } else if ((char === '-' || char === ' ') && !inParens && !inBrackets) {
          if (current.trim()) tokens.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      if (current.trim()) tokens.push(current.trim());
      
      const filteredTokens = tokens.filter(t => t && t.length > 0);
      
      const dingNote = transposeNote(rootNote, rootOctave, transpose);
      notes.push({ 
        ...dingNote,
        type: 'ding',
        freq: getFrequency(dingNote.note, dingNote.octave)
      });
      
      const rootIndex = NOTE_NAMES.indexOf(rootNote);
      
      let tonalOctave = rootOctave;
      let lastTonalIndex = rootIndex;
      let isFirstTonal = true;
      let bottomOctave = rootOctave;
      
      filteredTokens.forEach(token => {
        let type = 'tonal';
        let noteStr = token;
        
        if (token.startsWith('(') && token.endsWith(')')) {
          type = 'bottom';
          noteStr = token.slice(1, -1);
        } else if (token.startsWith('[') && token.endsWith(']')) {
          type = 'mutant';
          noteStr = token.slice(1, -1);
        }
        
        const parsed = parseNote(noteStr);
        if (!parsed) return;
        
        let noteOctave = parsed.octave;
        const noteIndex = NOTE_NAMES.indexOf(parsed.note);
        
        if (noteOctave === null) {
          if (type === 'tonal' || type === 'mutant') {
            if (isFirstTonal) {
              isFirstTonal = false;
            } else {
              if (noteIndex <= lastTonalIndex) {
                tonalOctave++;
              }
            }
            noteOctave = tonalOctave;
            lastTonalIndex = noteIndex;
          } else {
            noteOctave = bottomOctave;
          }
        } else {
          if (type === 'tonal' || type === 'mutant') {
            tonalOctave = noteOctave;
            lastTonalIndex = noteIndex;
            isFirstTonal = false;
          } else {
            bottomOctave = noteOctave;
          }
        }
        
        const transposed = transposeNote(parsed.note, noteOctave, transpose);
        notes.push({
          ...transposed,
          type: type,
          freq: getFrequency(transposed.note, transposed.octave)
        });
      });
      
      return notes;
    }
    
    function transposeNote(note, octave, semitones) {
      const noteIndex = NOTE_NAMES.indexOf(note);
      const newIndex = noteIndex + semitones;
      const newOctave = octave + Math.floor(newIndex / 12);
      const newNote = NOTE_NAMES[((newIndex % 12) + 12) % 12];
      return { note: newNote, octave: newOctave };
    }
    
    function getTransposition() {
      const scaleData = SCALES_DATA[state.scale];
      const baseNote = scaleData.baseRoot;
      const baseOctave = scaleData.baseOctave;
      
      const targetMatch = state.tonality.match(/^([A-G]#?)(\d)$/);
      if (!targetMatch) return 0;
      
      const targetNote = targetMatch[1];
      const targetOctave = parseInt(targetMatch[2]);
      
      const baseIndex = NOTE_NAMES.indexOf(baseNote) + baseOctave * 12;
      const targetIndex = NOTE_NAMES.indexOf(targetNote) + targetOctave * 12;
      
      return targetIndex - baseIndex;
    }
    
    function getCurrentNotes() {
      const scaleData = SCALES_DATA[state.scale];
      const pattern = scaleData.patterns[state.notes];
      if (!pattern) return [];
      
      const transpose = getTransposition();
      return parsePattern(pattern, scaleData.baseRoot, scaleData.baseOctave, transpose);
    }
    
    // ===== RENDER PLAYER =====
    function renderPlayer() {
      const notes = getCurrentNotes();
      const scaleData = SCALES_DATA[state.scale];
      const useFlats = scaleData.useFlats || false;
      const size = 780;
      const center = size / 2;

      const ding = notes.find(n => n.type === 'ding');
      const tonals = notes.filter(n => n.type === 'tonal');
      const mutants = notes.filter(n => n.type === 'mutant');
      const bottoms = notes.filter(n => n.type === 'bottom');

      const shellRadius = size * 0.35;
      const tonalRadius = size * 0.26;
      const dingSize = size * 0.08;       // Larger ding (was 0.07)
      const noteSize = size * 0.055;       // Larger notes for better touch targets (was 0.045)
      const mutantRadius = size * 0.15;
      const mutantNoteSize = noteSize * 0.85;  // Slightly larger mutants (was 0.8)
      const bottomRadius = size * 0.46;
      const bottomNoteSize = noteSize * 0.9;   // Slightly larger bottoms (was 0.85)
      
      const margin = 100;
      const viewBoxX = -margin;
      const viewBoxY = -margin;
      const viewBoxW = size + margin * 2;
      const viewBoxH = size + margin * 2.2;
      
      let svg = `
        <svg viewBox="${viewBoxX} ${viewBoxY} ${viewBoxW} ${viewBoxH}" width="${size}" height="${size * 1.1}" style="overflow: visible;">
          <defs>
            <radialGradient id="shell-grad" cx="30%" cy="30%">
              <stop offset="0%" stop-color="#5a5a5a"/>
              <stop offset="100%" stop-color="#3a3a3a"/>
            </radialGradient>
          </defs>
          
          <circle cx="${center}" cy="${center}" r="${shellRadius}" fill="url(#shell-grad)"/>
          <circle cx="${center}" cy="${center}" r="${shellRadius - 2}" fill="none" stroke="#555" stroke-width="1"/>
      `;
      
      if (ding) {
        const dingDisplay = toDisplayNotation(`${ding.note}${ding.octave}`, useFlats);
        svg += `
          <g class="note-group" data-note="${ding.note}${ding.octave}" data-freq="${ding.freq}">
            <circle cx="${center}" cy="${center}" r="${dingSize}" class="note-circle note-ding" stroke="#555" stroke-width="1"/>
            <text x="${center}" y="${center}" text-anchor="middle" dominant-baseline="central" class="note-label" fill="#bbb" font-size="16" font-family="system-ui">${dingDisplay}</text>
          </g>
        `;
      }

      mutants.forEach((note, i) => {
        const pos = getMutantPosition(i, mutants.length, mutantRadius, center);
        const noteDisplay = toDisplayNotation(`${note.note}${note.octave}`, useFlats);
        svg += `
          <g class="note-group" data-note="${note.note}${note.octave}" data-freq="${note.freq}">
            <circle cx="${pos.x}" cy="${pos.y}" r="${mutantNoteSize}" class="note-circle note-mutant" stroke="#6a5a4a" stroke-width="1"/>
            <text x="${pos.x}" y="${pos.y}" text-anchor="middle" dominant-baseline="central" class="note-label" fill="#bbb" font-size="13" font-family="system-ui">${noteDisplay}</text>
          </g>
        `;
      });

      tonals.forEach((note, i) => {
        const pos = getTonalPosition(i, tonals.length, tonalRadius, center);
        const noteDisplay = toDisplayNotation(`${note.note}${note.octave}`, useFlats);
        svg += `
          <g class="note-group" data-note="${note.note}${note.octave}" data-freq="${note.freq}">
            <circle cx="${pos.x}" cy="${pos.y}" r="${noteSize}" class="note-circle note-tonal" stroke="#555" stroke-width="1"/>
            <text x="${pos.x}" y="${pos.y}" text-anchor="middle" dominant-baseline="central" class="note-label" fill="#aaa" font-size="14" font-family="system-ui">${noteDisplay}</text>
          </g>
        `;
      });

      bottoms.forEach((note, i) => {
        const pos = getBottomPosition(i, bottoms.length, bottomRadius, center);
        const noteDisplay = toDisplayNotation(`${note.note}${note.octave}`, useFlats);
        svg += `
          <g class="note-group" data-note="${note.note}${note.octave}" data-freq="${note.freq}">
            <circle cx="${pos.x}" cy="${pos.y}" r="${bottomNoteSize}" class="note-circle note-bottom" fill="#2d2d2d" stroke="#666" stroke-width="1" stroke-dasharray="3 2"/>
            <text x="${pos.x}" y="${pos.y}" text-anchor="middle" dominant-baseline="central" class="note-label" fill="#888" font-size="13" font-family="system-ui">${noteDisplay}</text>
          </g>
        `;
      });
      
      svg += '</svg>';
      
      document.getElementById('player-visual').innerHTML = svg;
      
      let legendHTML = '<span class="legend-item"><span class="legend-dot legend-dot--tonal"></span> Tonales</span>';
      if (mutants.length > 0) {
        legendHTML += '<span class="legend-item"><span class="legend-dot legend-dot--mutant"></span> Mutants</span>';
      }
      if (bottoms.length > 0) {
        legendHTML += '<span class="legend-item"><span class="legend-dot legend-dot--bottom"></span> Bottoms</span>';
      }
      document.getElementById('player-legend').innerHTML = legendHTML;
      
      // Précharger les notes de la gamme
      preloadCurrentScale();
      
      document.querySelectorAll('.note-group').forEach(g => {
        g.addEventListener('click', () => {
          const noteName = g.dataset.note;
          if (noteName) playNote(noteName);
          g.classList.add('active');
          setTimeout(() => g.classList.remove('active'), 300);
        });
      });
    }
    
    function getTonalPosition(index, total, radius, center) {
      let angleDeg;
      const lastIndex = total - 1;
      const isEvenTotal = (total % 2 === 0);
      
      if (total === 1) {
        angleDeg = 270;
      } else if (total === 2) {
        angleDeg = index === 0 ? 250 : 290;
      } else if (index === lastIndex) {
        angleDeg = 90;
      } else if (isEvenTotal && index === 0) {
        angleDeg = 270;
      } else {
        let adjustedIndex, middleCount, isRight, sideIndex, notesPerSide;
        
        if (isEvenTotal) {
          adjustedIndex = index - 1;
          middleCount = total - 2;
          isRight = (adjustedIndex % 2 === 1);
          sideIndex = Math.floor(adjustedIndex / 2);
          notesPerSide = Math.ceil(middleCount / 2);
          
          if (isRight) {
            const step = notesPerSide > 1 ? 90 / (notesPerSide - 1) : 0;
            angleDeg = 315 + sideIndex * step;
            if (angleDeg >= 360) angleDeg -= 360;
          } else {
            const step = notesPerSide > 1 ? 90 / (notesPerSide - 1) : 0;
            angleDeg = 225 - sideIndex * step;
          }
        } else {
          isRight = (index % 2 === 0);
          sideIndex = Math.floor(index / 2);
          notesPerSide = Math.ceil((total - 1) / 2);
          
          if (isRight) {
            const range = 120;
            const step = notesPerSide > 1 ? range / (notesPerSide - 1) : 0;
            angleDeg = 290 + sideIndex * step;
            if (angleDeg >= 360) angleDeg -= 360;
          } else {
            const range = 120;
            const step = notesPerSide > 1 ? range / (notesPerSide - 1) : 0;
            angleDeg = 250 - sideIndex * step;
          }
        }
      }
      
      const angleRad = angleDeg * Math.PI / 180;
      const x = center + Math.cos(angleRad) * radius;
      const y = center - Math.sin(angleRad) * radius;
      
      return { x, y };
    }
    
    function getMutantPosition(index, total, radius, center) {
      if (total === 1) {
        return { x: center, y: center - radius };
      }
      
      const arcSpread = Math.min(120, 40 + (total - 1) * 30);
      const startAngle = 90 + arcSpread / 2;
      const step = arcSpread / (total - 1);
      const angleDeg = startAngle - (index * step);
      
      const angleRad = angleDeg * Math.PI / 180;
      const x = center + Math.cos(angleRad) * radius;
      const y = center - Math.sin(angleRad) * radius;
      
      return { x, y };
    }
    
    function getBottomPosition(index, total, radius, center) {
      if (total === 1) {
        return { x: center, y: center + radius };
      }
      
      const arcSpread = Math.min(140, 40 + (total - 1) * 25);
      const startAngle = 270 - arcSpread / 2;
      const step = arcSpread / (total - 1);
      const angleDeg = startAngle + (index * step);
      
      const angleRad = angleDeg * Math.PI / 180;
      const x = center + Math.cos(angleRad) * radius;
      const y = center - Math.sin(angleRad) * radius;
      
      return { x, y };
    }
    
    // ===== UPDATE DISPLAY =====
    function updateDisplay() {
      const scaleData = SCALES_DATA[state.scale];
      // Use unified logic: flats only for natural roots + flat-preferring scales
      const useFlats = shouldUseFlats(state.tonality, scaleData);
      const notes = getCurrentNotes();

      const rootMatch = state.tonality.match(/^([A-G]#?)(\d)$/);
      const rootNote = rootMatch ? rootMatch[1] : state.tonality;
      // Root display: never convert sharp roots (F# stays F#, not Gb)
      const rootDisplay = useFlats ? (SHARPS_TO_FLATS[rootNote] || rootNote) : rootNote;
      document.getElementById('display-name').textContent = `${rootDisplay} ${scaleData.name}`;
      document.getElementById('display-notes').textContent = notes.map(n => toDisplayNotation(`${n.note}${n.octave}`, useFlats)).join(' • ');
      document.getElementById('display-mood').textContent = `${state.notes} notes`;

      // Tonality label: always show standard notation (sharps)
      document.getElementById('label-tonality').textContent = state.tonality;

      document.getElementById('notes-value').textContent = state.notes;
      document.getElementById('notes-minus').disabled = state.notes <= 9;
      document.getElementById('notes-plus').disabled = state.notes >= 17;

      // Nom de la configuration
      const configName = `${rootDisplay} ${scaleData.name} ${state.notes} notes`;
      
      // Vérifier la faisabilité AVANT de calculer le prix
      let feasibilityStatus = 'ok';
      if (typeof FeasibilityModule !== 'undefined') {
        const result = FeasibilityModule.checkFeasibility(notes, state.size);
        feasibilityStatus = result.status;
      }
      
      // Calculer le prix avec le status de faisabilité
      const price = calculatePrice(notes, state.size, feasibilityStatus);
      document.getElementById('total-price').textContent = price.toLocaleString('fr-FR') + ' €';
      
      // Préparer le lien de commande
      const orderParams = new URLSearchParams({
        scale: state.scale,
        tonality: state.tonality,
        notes: state.notes,
        tuning: state.tuning,
        size: state.size,
        price: price,
        name: `${rootDisplay} ${scaleData.name}`
      });
      const orderUrl = `commander.html?${orderParams.toString()}`;
      document.getElementById('btn-order').href = orderUrl;
      document.getElementById('btn-order').dataset.originalHref = orderUrl;
      
      // Mettre à jour l'UI de faisabilité (chips, hint, bouton)
      if (typeof FeasibilityModule !== 'undefined') {
        FeasibilityModule.update(state, notes, SCALES_DATA, parsePattern, {
          configName: configName
        });
      }
      
      renderPlayer();
    }
    
    // ===== BIND EVENTS =====
    function bindEvents() {
      const toggleBtn = document.getElementById('toggle-advanced');
      const advancedContent = document.getElementById('advanced-content');
      toggleBtn.addEventListener('click', () => {
        toggleBtn.classList.toggle('open');
        advancedContent.classList.toggle('open');
      });
      
      document.getElementById('notes-minus').addEventListener('click', () => {
        if (state.notes > 9) { state.notes--; updateDisplay(); }
      });
      document.getElementById('notes-plus').addEventListener('click', () => {
        if (state.notes < 17) { state.notes++; updateDisplay(); }
      });
      
      document.querySelectorAll('#chips-scale .chip').forEach(chip => {
        chip.addEventListener('click', () => {
          document.querySelectorAll('#chips-scale .chip').forEach(c => c.classList.remove('active'));
          chip.classList.add('active');
          state.scale = chip.dataset.value;
          
          const scaleData = SCALES_DATA[state.scale];
          state.tonality = scaleData.baseRoot + scaleData.baseOctave;
          document.querySelectorAll('#chips-tonality .chip').forEach(c => {
            c.classList.toggle('active', c.dataset.value === state.tonality);
          });

          updateDisplay();
        });
      });
      
      document.querySelectorAll('#chips-tonality .chip').forEach(chip => {
        chip.addEventListener('click', () => {
          // Ne pas changer si le chip est désactivé
          if (chip.disabled || chip.classList.contains('chip--disabled')) return;
          
          document.querySelectorAll('#chips-tonality .chip').forEach(c => c.classList.remove('active'));
          chip.classList.add('active');
          state.tonality = chip.dataset.value;
          updateDisplay();
        });
      });
      
      document.querySelectorAll('#cards-tuning .radio-card').forEach(card => {
        card.addEventListener('click', () => {
          document.querySelectorAll('#cards-tuning .radio-card').forEach(c => c.classList.remove('active'));
          card.classList.add('active');
          state.tuning = card.dataset.value;
          updateDisplay();
        });
      });
      
      document.querySelectorAll('#cards-size .radio-card').forEach(card => {
        card.addEventListener('click', () => {
          document.querySelectorAll('#cards-size .radio-card').forEach(c => c.classList.remove('active'));
          card.classList.add('active');
          state.size = card.dataset.value;
          updateDisplay();
        });
      });
      
      document.getElementById('btn-play').addEventListener('click', playScale);
    }
    
    async function playScale() {
      const btn = document.getElementById('btn-play');
      const notes = getCurrentNotes();
      const sortedNotes = [...notes].sort((a, b) => a.freq - b.freq);
      
      btn.classList.add('playing');
      btn.querySelector('span').textContent = '...';
      
      for (let i = 0; i < sortedNotes.length; i++) {
        await delay(280);
        const noteName = `${sortedNotes[i].note}${sortedNotes[i].octave}`;
        playNote(noteName);
        
        const noteGroups = document.querySelectorAll('.note-group');
        noteGroups.forEach(g => {
          if (g.dataset.note === noteName) {
            g.classList.add('active');
            setTimeout(() => g.classList.remove('active'), 280);
          }
        });
      }
      
      btn.classList.remove('playing');
      btn.querySelector('span').textContent = 'Écouter';
    }
    
    function delay(ms) {
      return new Promise(r => setTimeout(r, ms));
    }
    
    // ===== SWIPE NAVIGATION SYSTEM =====
    (function() {
      const wrapper = document.getElementById('boutique-wrapper');
      const tabs = document.querySelectorAll('.boutique-tab');
      const dots = document.querySelectorAll('.boutique-dot');
      const panelConfig = document.getElementById('panel-config');
      const panelStock = document.getElementById('panel-stock');
      
      // Nav band elements
      const navBand = document.getElementById('nav-band');
      const navBandBtn = document.getElementById('nav-band-btn');
      const navBandText = document.getElementById('nav-band-text');
      const navBandBadge = document.getElementById('nav-band-badge');
      const navBandCount = document.getElementById('nav-band-count');
      const arrowDown = document.getElementById('nav-arrow-down');
      const arrowUp = document.getElementById('nav-arrow-up');
      
      let currentSection = 'config'; // 'config' or 'stock'
      
      if (!wrapper) return;
      
      // Update active state based on scroll position
      function updateActiveState(panel) {
        tabs.forEach(tab => {
          tab.classList.toggle('active', tab.dataset.panel === panel);
        });
        dots.forEach(dot => {
          dot.classList.toggle('active', dot.dataset.panel === panel);
        });
      }
      
      // Update nav band state
      function updateNavBand(section) {
        if (!navBand || window.innerWidth <= 768) return;
        
        currentSection = section;
        
        if (section === 'config') {
          navBandText.textContent = 'Instruments en stock';
          arrowDown.style.display = 'block';
          arrowUp.style.display = 'none';
          if (navBandBadge) navBandBadge.style.display = 'inline-flex';
          navBand.classList.remove('is-stock');
        } else {
          navBandText.textContent = 'Créer sur mesure';
          arrowDown.style.display = 'none';
          arrowUp.style.display = 'block';
          if (navBandBadge) navBandBadge.style.display = 'none';
          navBand.classList.add('is-stock');
        }
      }
      
      // Scroll to panel
      function scrollToPanel(panel) {
        const target = panel === 'config' ? panelConfig : panelStock;
        if (target) {
          // Mobile: horizontal scroll
          if (window.innerWidth <= 768) {
            wrapper.scrollTo({
              left: target.offsetLeft,
              behavior: 'smooth'
            });
          } else {
            // Desktop: vertical scroll
            if (panel === 'config') {
              window.scrollTo({ top: 0, behavior: 'smooth' });
            } else {
              // Scroll to stock section (after nav band)
              const stockSection = document.getElementById('flash-sales');
              if (stockSection) {
                stockSection.scrollIntoView({ behavior: 'smooth' });
              }
            }
          }
        }
      }
      
      // Tab click handlers
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          scrollToPanel(tab.dataset.panel);
        });
      });
      
      // Dot click handlers
      dots.forEach(dot => {
        dot.addEventListener('click', () => {
          scrollToPanel(dot.dataset.panel);
        });
      });
      
      // Nav band click handler
      if (navBandBtn) {
        navBandBtn.addEventListener('click', () => {
          if (currentSection === 'config') {
            scrollToPanel('stock');
          } else {
            scrollToPanel('config');
          }
        });
      }
      
      // Detect scroll position on mobile (horizontal)
      let scrollTimeout;
      wrapper.addEventListener('scroll', () => {
        if (window.innerWidth > 768) return;
        
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          const scrollLeft = wrapper.scrollLeft;
          const panelWidth = wrapper.offsetWidth;
          const activePanel = scrollLeft < panelWidth / 2 ? 'config' : 'stock';
          updateActiveState(activePanel);
        }, 50);
      });
      
      // Detect scroll position on desktop (vertical)
      function checkDesktopScroll() {
        if (window.innerWidth <= 768) return;
        
        if (!navBand) return;
        
        // Check if nav band is stuck (at top under header)
        const navBandRect = navBand.getBoundingClientRect();
        const headerHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--header-height') || '64');
        
        // If the nav band is stuck at the top (its top equals header height), we're in stock mode
        const isStuck = navBandRect.top <= headerHeight + 2; // +2 for tolerance
        
        if (isStuck) {
          updateNavBand('stock');
        } else {
          updateNavBand('config');
        }
      }
      
      // Throttled scroll handler for desktop
      let ticking = false;
      window.addEventListener('scroll', () => {
        if (!ticking) {
          window.requestAnimationFrame(() => {
            checkDesktopScroll();
            ticking = false;
          });
          ticking = true;
        }
      });
      
      // Update stock count in tab and nav band
      function updateStockCount() {
        const stockCountTab = document.getElementById('stock-count-tab');
        let count = 0;

        if (typeof MistralAdmin !== 'undefined' && MistralAdmin.FlashAnnonces && typeof MistralAdmin.FlashAnnonces.getActive === 'function') {
          const annonces = MistralAdmin.FlashAnnonces.getActive();
          count = annonces.length;
        }
        
        if (stockCountTab) {
          stockCountTab.textContent = count;
        }
        
        if (navBandCount) {
          navBandCount.textContent = count;
        }
      }
      
      // Expose scrollToStock for compatibility
      window.scrollToStock = function() {
        scrollToPanel('stock');
      };
      
      // Init
      setTimeout(() => {
        updateStockCount();
        checkDesktopScroll();
      }, 100);
      window.addEventListener('storageUpdate', updateStockCount);
      window.addEventListener('stockUpdated', (e) => {
        const count = e.detail?.count || 0;
        if (document.getElementById('stock-count-tab')) {
          document.getElementById('stock-count-tab').textContent = count;
        }
        if (navBandCount) {
          navBandCount.textContent = count;
        }
      });
      window.addEventListener('resize', checkDesktopScroll);
    })();
    
    // ===== INIT =====
    document.addEventListener('DOMContentLoaded', () => {
      bindEvents();
      updateDisplay();
    });
  </script>
  
  <!-- Scripts -->
  
  <script src="js/main.js"></script>
  
  <!-- Admin Scripts -->
  <script src="js/admin-core.js"></script>
  <script src="js/boutique-admin.js"></script>
<script src="js/mistral-stats.js"></script>
</body>
</html>
